= RP2350のメモリと内部構造 ― Lチカが動く仕組みを理解する

//abstract{
Re:VIEW Starterを使っていただき、ありがとうございます。

この章では、Re:VIEW Starterを使うために必要となる「Ruby」と「TeXLive」のインストール方法を説明します。
//}

== はじめに ― RP2350の中で何が起きているのか

マイコン開発の世界では、「@<b>{LEDを点滅させる}」こと（@<b>{Lチカ}）が最初の一歩とされています。
しかし、LEDが一瞬光る裏では、@<b>{CPU、メモリ、クロック、入出力回路（GPIO）}といった多数の要素が連携して動いています。

この章では、その「マイコンの中で起きていること」を、@<b>{RP2350}という具体的なチップを例に理解していきます。

=== RP2350とは何か

RP2350は、Raspberry Pi社が開発した@<b>{マイクロコントローラ（マイコン、MCU）}です。
「Raspberry Pi Pico 2」、「@<b>{Raspberry Pi Pico 2W}」などの小型ボードに搭載され、@<b>{低消費電力・拡張性}を両立した設計が特徴です。

同社の初代マイコン@<b>{RP2040}の後継として登場し、内部構造がより洗練されています。
具体的には次のような進化がありました。

 * CPUコアがCortex-M0+から@<b>{Cortex-M33}へ
 ** より高性能で、セキュリティ機能（TrustZone）を搭載

 * SRAMの大容量化と分割構造化
 ** より多くのタスクや無線処理を同時に実行可能

 * USB High-Speed / BLE対応
 ** 通信機能が強化され、外部機器やスマートフォンと直接やり取りできる

 * DMA・PIOの改良
 ** 入出力の高速制御をCPUに頼らず行える

現時点で、SRAM, DMA, PIOなどの用語の意味がわからなくても安心してください。
それぞれの詳細は、この章の中で解説します。

このように、RP2350は「@<b>{組込みプログラミングの学習用にも、実用製品開発にも使える}」という位置づけにあります。

=== 「LEDが点滅する」までに起きていること

マイクロコントローラ（マイコン、MCU）とは、CPU・RAM・ROM・I/Oポートなどを1つの集積回路（IC）にまとめた極小コンピュータです。

ここではMCUの1つである@<b>{RP2350}が持つさまざまな機能と、それらの動作を理解するため、@<list>{blinky_example}のようなRustコードを考えてみましょう。

//list[blinky_example][Lチカコードの中心部]{
led.set_high(); // LED点灯
delay_ms(500);
led.set_low();  // LED消灯
delay_ms(500);
//}

これはLチカをするコードの一部であり、以下のような処理をしています。

 1. LEDを点灯する
 2. 500ミリ秒待機する
 3. LEDを消灯する
 4. 500ミリ秒待機する

この数行の裏では、RP2350の内部で次のような一連の動作が発生しています。

これらの仕組みを理解することで、単なる「LEDが光る」という現象が、「どのようにCPUやメモリが協力して実現されているのか」という視点から見えるようになります。

====[notoc] ① プログラム（命令）を外部フラッシュメモリに書き込む

@<list>{blinky_example}のLチカコードをMCUに実行させるためには、このプログラムをMCUに読める形で@<b>{書き込む}必要があります。

RP2350の場合、書き込み先はMCU内部ではなく、@<b>{外部のフラッシュメモリ}です。
書き込まれたプログラムは@<b>{命令}の羅列として扱われます。
また、@<code>{delay_ms}のような@<b>{関数}を定義して、複数の命令群をパッケージ化することもできます。

==== ② 内部メモリ（SRAM）上にデータを配置

@<code>{led}という@<b>{変数}は、MCU内部のメモリ（@<b>{SRAM}）に配置されます。

外部フラッシュメモリ・SRAMともに、メモリ上の情報が配置される場所は@<b>{アドレス}と呼ばれ、その名のとおり「番地」として扱われます。

==== ③ CPUが命令を実行

プログラム（＝命令）を実行するのは@<b>{CPU}です。
CPUは@<b>{レジスタ}という小さなメモリ群を持ち、そこに外部フラッシュメモリやSRAMにある情報をコピーしながら命令を処理します。

CPUが正しく処理を行うためには、ほしい情報があるアドレスを正確に把握しておく必要があります。

==== ④ GPIOレジスタへの書き込み

@<code>{led}変数に続く@<code>{.set_high}や@<code>{.set_low}は、@<b>{メソッド}と呼ばれる関数の一種です。
これらはLEDの点滅と消灯を実行します。

RP2350のいくつかのピンには汎用入出力（@<b>{GPIO}）の機能が割り当てられており、ピンにかかる電圧の高/低（@<b>{High/Low}）を制御します。
GPIOも独自のレジスタを持っており、それらの値によってピン電圧を操作できます。

==== ⑤ タイマで時間を待つ

@<code>{delay_ms}関数では、MCUを一定時間待機させます。
そのためにMCUが持つタイマの機能を利用しますが、これも各タイマが持つレジスタの操作によって実行します。

==== まとめ

これらはすべて、@<b>{メモリ空間上の異なる領域が協調して動く}ことで成立しています。
RP2350を理解するとは、この「データと命令がどこを通って動くか」を知ることにほかなりません。

次章からは、ここで登場したパーツについて詳しく見ていきます。

== 外部フラッシュメモリと内部SRAM ― 命令とデータの居場所

RP2350がプログラムを実行するとき、命令とデータは異なる種類のメモリに置かれます。
命令（プログラムの本体）は外部の@<b>{フラッシュメモリ}に、実行中に変化するデータ（変数など）は@<b>{SRAM}に配置されます。

それぞれのメモリの特性を理解することが、RP2350の動作を正確に把握する第一歩です。

=== メモリの種類とその役割

RP2350には複数のメモリが存在します。
それぞれの性質と用途をまとめると、次のようになります。

//table[tbl-memory][代表的なメモリの一覧]{
名称	主な用途	容量	電源を切ると消えるか	内容の例
===================================
フラッシュメモリ	プログラムや定数の保存	大	消えない（不揮発）	LED制御プログラム
SRAM	実行中のデータの保持	小	消える（揮発）	変数、スタックなど
ROM/ブートROM	起動時の制御コード	極小	消えない（不揮発）	USB書き込み・初期化処理
//}

つまり、

 - フラッシュメモリ：プログラムを長期的に保存する場所 - SRAM：実行中にCPUが利用する一時的な作業領域
 - ROM／ブートROM：起動時に最初に動作する制御コード

という役割分担になっています。

=== フラッシュメモリ ― 命令の「保管庫」

RP2350にはプログラムを保持する内蔵フラッシュメモリがなく、代わりにボード上の@<b>{外部フラッシュメモリ}にプログラムを書き込みます。
そのため、Raspberry Pi Pico 2Wには4MBのフラッシュメモリが搭載されています。

（ちなみに、@<b>{RP2354}という派生チップは、プログラム保存用のフラッシュメモリをチップ内に積層した構成になっています）

内部SRAMにプログラムを直接書き込まない理由は、メモリの@<b>{性質とコスト構造}にあります。

 - SRAMは非常に高速だが容量が小さく、電源を切ると内容が消える。プログラムを保持するには不向き。
 -フラッシュメモリは書き換えは遅いが、電源を切っても消えず、安価に大容量を確保できる。

RP2350が内蔵するSRAMは520KBであり、多くのアプリケーションに必要な数百KB〜数MB規模のプログラムを格納するには容量が不足します。
したがって、命令を長期間保持できるフラッシュメモリが必要となります。

また、命令の他にも、プログラムの実行を通して値が変化しない@<b>{定数}（@<list>{const}）もフラッシュメモリに保存されます。

//list[const][定数の例]{
const DELAY_DEFAULT: u32 = 250;
//}

=== QSPIフラッシュとXIP ― フラッシュメモリ上の命令を直接実行する仕組み

RP2350は、フラッシュメモリを@<b>{QSPI}（Quad Serial Peripheral Interface）という高速な通信方式で接続しています。
1本の通信線で、データを1ビットずつ順番に送る通信方式を@<b>{シリアル通信}といい、代表的なものに@<b>{SPI}方式があります。
QSPIはその改良版で、4本のデータ線を使用して並列に通信を行いデータ転送を高速化できます。

QSPIインタフェースの重要な特徴は、外部フラッシュメモリをCPUのアドレス空間に直接マッピングできることです。
この仕組みにより、CPUはフラッシュ上の命令をあたかも内部メモリにあるかのように読み出して実行できます。
この方式を@<b>{XIP}（Execute In Place） と呼びます。

====[notoc] XIPがある場合とない場合の違い

XIPによって、CPUはフラッシュメモリの内容を直接読み出して命令を実行できるため、起動時にプログラムをSRAMへコピーする必要がありません。
その結果、起動が高速化され、SRAMを実行時データのみに使えるという利点があります。

一方、XIPがなければ次のような処理が必要になります。

起動時にブートROMがフラッシュから命令を読み出す。

それらをSRAMにすべてコピーする。

CPUがSRAM上のプログラムを実行する。

この方法では起動時間が長くなり、SRAMの多くをコードが占有します。
RP2350が採用するXIP構成は、外部フラッシュの大容量をそのまま活かし、
SRAMを動的な処理専用に温存できるという点で合理的です。





そのため、RP2350の外部に@<b>{不揮発メモリ}（外部フラッシュメモリ）を配置し、プログラムはそこに保存します。

プログラムは「〇〇をしなさい」という@<b>{命令}の手順を示したものです。
命令は1つ1つ示すこともできますが、@<list>{blinky_example}に登場する@<code>{delay_ms}のように、@<b>{関数}として複数の命令群をパッケージ化することもできます。
この関数の情報も外部フラッシュに保存されます。

==== ② 内部メモリ（SRAM）上にデータを配置

@<code>{led}という@<b>{変数}は、MCU内部のメモリ（@<b>{SRAM}）に配置されます。

外部フラッシュ・SRAMともに、メモリ上の情報が配置される場所はアドレスと呼ばれ、その名のとおり「番地」として扱われます。

==== ③ CPUが命令を実行

プログラムに書かれた処理を実行するのは@<b>{CPU}です。

CPUは内部に@<b>{レジスタ}と呼ばれる小さなメモリ群を持っています。
レジスタは非常に高速にアクセスできるため、演算や制御の一時的な値を保持する場所として使われます。

CPUは外部フラッシュからプログラムの一部をレジスタにコピーし、そこに書かれた命令を処理します。
その際、変数を参照する必要がある場合には、別のレジスタにSRAMから変数をコピーします。逆に、レジスタの内容をSRAMにコピーすることもできます。

1つの命令を処理したあとは、また次の命令をレジスタにコピーして処理し、順次プログラムの内容を実行していきます。
CPUが正しく処理を行うためには、コピーすべき情報を持っている外部フラッシュやSRAMのアドレスを正確に把握しておく必要があります。

==== ④ GPIOレジスタへの書き込み


この関数では、LEDにつながったピンの電位を@<b>{High}または@<b>{Low}にし、LEDを点灯または消灯状態に切り替えます。
このような単純なピンの使い方を@<b>{GPIO}（General-Purpose Input/Output、汎用入出力）といいます。また、GPIOのように、CPUの外部で様々な機能を提供する周辺回路のことをペリフェラルといいます。

CPU同様、それぞれのペリフェラルは固有のレジスタを持っており、その値によって設定や状態確認を行うことができます。
たとえば、GPIO出力のレジスタに書き込むことでHighまたはLowのレベルを変更したり、GPIO入力のレジスタを読むことで現在入ってきている信号のHigh・Lowを確認したりできます。

RP2350をはじめとする多くのMCUでは、外部フラッシュやSRAMと同様に、各ペリフェラルのレジスタにもアドレスが割り振られています。
そのため、CPUからは各ペリフェラルのレジスタがメモリ空間の一部であるように見えます。
このような機能を@<b>{メモリマップドI/O}といい、メモリの読み書きを通してペリフェラルを制御することができます。

詳しいアドレス構造や、どの範囲が外部フラッシュ・SRAM・GPIOに割り当てられているかは、次節で図を使って詳しく説明します。

==== ⑤ タイマで時間を待つ

@<code>{delay_ms}関数では、一定時間待機する処理を実行します。
そのためにMCUが持つ各タイマの機能を利用しますが、これもメモリマップドI/Oの効果によって、アドレスへの読み書きとして表現できます。



== RP2350の内部構成とアドレス空間

この節では、@<b>{プログラム（命令）とデータがRP2350内部のどこを通って動くか}を、メモリマップ（アドレス空間）という“地図”で確認します。
ここを押さえると、後の「@<code>{memory.x}でどこに何を置くか」を迷わず決められるようになります。

=== 全体像：何がどこにある？

RP2350は、ユーザプログラムを実行するデュアルコア（Cortex-M33 あるいは RISC-V Hazard3 を選択）と、
それらを支えるオンチップSRAM、外部メモリ(XIP)、各種ペリフェラルで構成されています。
最重要ポイントだけ先にまとめます。




RP2040との違い ― 性能と構造の進化点
　初心者が混乱しやすいRP2040との相違を整理し、RP2350の新機能（Cortex-M33・SRAM拡張・TrustZoneなど）を理解。

RP2350の内部構成とアドレス空間
　マイコンの「地図」としてのメモリマップを紹介。BootROM、SRAM、Flash、ペリフェラルなどの関係を図解。

SRAM ― 実行中の作業机
　変数・スタック・DMAバッファなどの実体を、実行中の視点から理解。
　複数バンク構成・アクセス制御・SRAMとFlashの使い分けを説明。

Flash（XIP）― プログラムの住む場所
　プログラムがどこに保存され、どのように実行されるか（XIP動作、読み込み速度、SRAM展開など）を解説。

GPIO・PIO・DMA ― ハードウェアを動かすための仕組み
　LED点滅を例に、RP2350でGPIOを操作する流れを説明。
　PIOとDMAがどのようにCPUの負荷を減らし、タイミングを正確に保つかを解説。

タイマと非同期処理 ― 時間を扱うための基本
　Timer や Duration による時間管理の仕組みを、ハードウェアタイマやSysTickとの関連から説明。
　async/awaitモデルの利点を述べる。

BLE制御の基盤 ― 無線機能とメモリ構成の関係
　Pico 2W との接続は後の章で扱うが、ここではRP2350内部で CYW43通信（PIO+DMA）とBLEスタックがどう支えられているかを整理。

共有データと同期 ― Atomic変数とタスク間通信
　AtomicU32 を例に、スレッドセーフにデータを共有する仕組みを理解。マルチコア化や割り込み安全との関係も補足。

RP2350のメモリマップとmemory.xへの橋渡し

CPUは外部フラッシュやSRAMのアドレスを走り回りながら処理を実行します。

==== ② CPUコアが命令を実行

外部フラッシュに書き込まれたプログラムは命令として読み出され、@<b>{CPUコア}（処理を実行する部分）で順次処理されます。

さらに、CPUは命令処理を複数段階に分け、並列に実行して効率化することもできます。
このような仕組みを@<b>{パイプライン}といいます。

==== ③ 内部メモリ（SRAM）上の変数やスタックにアクセス

@<list>{blinky_example}に登場する@<code>{led}という@<b>{変数}は、MCU内部のメモリ（@<b>{SRAM}）に配置され、CPUが読み書きできるようになります。

メモリ上の情報が配置される場所はアドレスと呼ばれ、その名のとおり「番地」として扱われます。CPUは外部フラッシュやSRAMのアドレスを走り回りながら処理を実行します。

CPUは@<b>{レジスタ}と

@<code>{delay_ms}は@<b>{関数}です。
関数とは、一連の命令をまとめたパッケージで、他の命令と同様、外部フラッシュに情報が保存されています。

CPUが外部フラッシュを読んでプログラム（命令）を順次処理していくと、「次の処理は関数『A』を実行」と書かれた命令に行き当たります。
するとCPUは「関数『A』」が書かれているアドレスにジャンプして、そこに書かれた処理を行います。

CPUは「関数『A』」の実行中に、必要な変数を作ることがあります。
ただし、この変数は「関数『A』」の中でのみ必要なものなので、関数の実行後に破棄されます。
このような一時的な変数を@<b>{ローカル変数}といいます。

また、「関数『A』」の実行後は、CPUはジャンプ前に実行していた命令のアドレスまで戻ってきて、あとの処理を続ける必要があります。
そのために、CPUは「関数『A』」のあどれすにジャンプする前に、現在地に相当する@<b>{戻りアドレス}を保存しておきます。
「関数『A』」の実行後、CPUがそこに戻ってきた後は、戻りアドレスは不要になるため破棄されます。

ローカル変数や戻りアドレスなどの一時的な情報は、SRAM内部の@<b>{スタック}と呼ばれる領域に積み上げられ、不要になったら削除されます。

==== ④ 